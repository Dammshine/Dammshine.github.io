<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-NodesNotInCycle" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/06/NodesNotInCycle/" class="article-date">
  <time class="dt-published" datetime="2022-05-06T03:07:41.000Z" itemprop="datePublished">2022-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/06/NodesNotInCycle/">NodesNotInCycle</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="NodesNotInCycle"><a href="#NodesNotInCycle" class="headerlink" title="NodesNotInCycle"></a>NodesNotInCycle</h2><p>The problem requires ones to implement an algorithm to determine all node that are not in cycle, or oppososite, all nodes that are in cycle.</p>
<h4 id="My-apparoach-to-the-question"><a href="#My-apparoach-to-the-question" class="headerlink" title="My apparoach to the question"></a>My apparoach to the question</h4><p>The naive appaproch would be implementating a cycle-detect algorithm and runs on every node. Known the general approach would be <strong>DFS</strong> and time complexity would be O(V^2) in directed diagram implemeneted by adjency matrix, this apparoch will have time complexity of O(V^3).</p>
<p>My approach would be, I will aim to run only one DFS for each conencted component, so that in worst case, I will have time complexity of O(V^2). So that my idea is to keep two array,</p>
<ol>
<li>Color array (Color the path when approching, so that one can easiy spot a <strong>back edge</strong>, uncolor the path when rewinding, so program won’t fail because <strong>forward edge</strong>)</li>
<li>Root array  (Store the path info, so my program can fill the node that are in a cycle when it detects one using color array).</li>
</ol>
<p>And my blunder mades here, I mistakenly thought <strong>color array</strong> would allow me to visit an arbitary node for multiple times, but not in <strong>same path,</strong> while if I only color the vertex, it will only allow me to acheive not visit same <strong>combination of paths</strong> in my program.  This results my program’s worst case become O(n!). (Unfortunately, I mistakenly thought this would give O(n^2) since I only run one DFS per connected component)</p>
<p>To fix this, my idea would be instead of only using a colored array(It’s still handy for deteching cycle), I would use a <strong>2-D matrix</strong> to store the paths that being visited. So even I will decolor the <strong>color array</strong> when rewinding to ensure my DFS is able to visit same node for mutiple time, each path will only be visited once. So the qesuodo code would be follow</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DFS(Graph g, int notInCycle[], int color[], int root[], int edgecolor[][], int vertex, int parent) &#123;</span><br><span class="line">    // Fill path info, and the color the vertex</span><br><span class="line">    <span class="built_in">let</span> root[v] = parent</span><br><span class="line">    <span class="built_in">let</span> color[v] = VISIT</span><br><span class="line"></span><br><span class="line">    // Inspect all edges</span><br><span class="line">    <span class="keyword">for</span> i = 0..V</span><br><span class="line">        <span class="keyword">if</span> i == vertex </span><br><span class="line">            skip</span><br><span class="line">        end <span class="keyword">if</span></span><br><span class="line">        // Inspect edge from v to i, and the node i not being visit</span><br><span class="line">        <span class="keyword">if</span> vertex, i belong g.edges and color[i] != VISIT</span><br><span class="line">            // Fill color to this edge, or skip <span class="keyword">if</span> this edge being vsited</span><br><span class="line">            <span class="keyword">if</span> edgecolor[vertex][i] != VISIT</span><br><span class="line">                edgecolor[vertex][i] = VISIT</span><br><span class="line">            end <span class="keyword">if</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> <span class="literal">true</span></span><br><span class="line">                skip</span><br><span class="line">            end <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line">            DFS(g, notInCycle, color, root, edgecolor, i, vertex);</span><br><span class="line">        end <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> vertex, i belong g.edges and color[i] == VISIT</span><br><span class="line">            // This will fill the cycle status of vetrex <span class="keyword">in</span> the cycle that detected</span><br><span class="line">            traceBackAndFill(notInCycle, root, v, i, GraphNumVertices(g));</span><br><span class="line">    end <span class="keyword">for</span></span><br><span class="line"></span><br><span class="line">    // After the search, I will decolor the vertex, allow other paths can visit the vertex</span><br><span class="line">    color[v] = NOT_VISIT</span><br><span class="line"></span><br><span class="line">    // I will also update the status of notInCycle</span><br><span class="line">    <span class="keyword">if</span> notInCycle != TRUE</span><br><span class="line">        notInCycle = FALSE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/06/NodesNotInCycle/" data-id="cl2tvu2260000fwtr9vape3td" data-title="NodesNotInCycle" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/COMP2521/" rel="tag">COMP2521</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Things-I-know-so-far" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/04/Things-I-know-so-far/" class="article-date">
  <time class="dt-published" datetime="2022-05-04T03:15:46.000Z" itemprop="datePublished">2022-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/04/Things-I-know-so-far/">Things I know so far</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Data-structure"><a href="#Data-structure" class="headerlink" title="Data structure"></a>Data structure</h2><p>The data structure that I’ve met so far is pretty primitive, include a few advanced ones. It can be category as array and list, tree, graph. </p>
<h4 id="Array-and-list"><a href="#Array-and-list" class="headerlink" title="Array and list"></a>Array and list</h4><ol>
<li>Array<br> a. Array with circular implementation. It gives a one dimensional space felling.<br> b. 2-D array, used in many situation, for example will be the graph. Also used to implement matrix.<br> c. Heap, use an array. It can be also included in tree.<br> d. <strong>Rooted tree</strong>, using an array to represent a tree structure.</li>
<li>Linked list<br> a. Singly linked list, double linked list. List store head and tail.<br>The list is ideal to implement queue like structure. As itself looks like a queue.<br>The graph can also use linked list, for scarse diagram for ideal.<br> b. <strong>Skipped list</strong><br> c. <strong>Sqrt list</strong><br> d. Linked list contains parent pointer can be used to implement <strong>disjoint set</strong></li>
</ol>
<p>I should take time to visit chapter 12, data structure and algorithm in c++.</p>
<h4 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h4><ol>
<li>Binary Tree<br> a. Binary search tree. Ideal for store element, search element.<br> b. Self balanced tree. Build upon binary tree, can garunteed the maximum search cost within boundary,<br>by the cost of coefficient and extra memory<br>1. <strong>Red Black tree</strong><br>2. AVL tree</li>
<li>Non-binary tree<br> a. 2-3-4 Tree. B tree.<br> b. <strong>rooted tree</strong></li>
<li>Tries<br> All above tree like structure uses, object space decomposition, tries uses key space decomposition.<br> a. Alaphabet tries. To find duplicate words, or count words.<br> b. Huffman coding tree. To compress info.</li>
<li><strong>Spatial Data structure</strong><br> a. K-D tree<br> b. PR quadtree</li>
</ol>
<h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><ol>
<li>Implementation would just be adjency list, adjency matrix and array of edges.<br>But the more important things would be<ol>
<li>SSSP problem <ul>
<li>Dijistra’s algorithm</li>
</ul>
</li>
<li>ASSP problem<ul>
<li>Floyd-warshall</li>
<li>Johnson</li>
</ul>
</li>
<li>MST<ul>
<li>Prim</li>
<li>Kruskal</li>
</ul>
</li>
<li>Max-flow</li>
</ol>
</li>
</ol>
<h4 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h4><p>Three different resolution</p>
<ol>
<li>Chaining</li>
<li>Linear probing</li>
<li>Double hashing<br>The last two can also be classify as category Open Addressing.</li>
</ol>
<p>Hash function</p>
<h4 id="Ideology"><a href="#Ideology" class="headerlink" title="Ideology"></a>Ideology</h4><ol>
<li>Divide and conquer</li>
<li>Randomise algorithm</li>
<li>DP</li>
<li>Greedy</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/04/Things-I-know-so-far/" data-id="cl2secusm00011wtr74de71b7" data-title="Things I know so far" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Personal/" rel="tag">Personal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Report/" rel="tag">Report</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Hash-Table" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/03/Hash-Table/" class="article-date">
  <time class="dt-published" datetime="2022-05-03T03:51:13.000Z" itemprop="datePublished">2022-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/03/Hash-Table/">Hash Table</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Type of Hash Table</p>
<ol>
<li>Chaining<br> 1. </li>
<li>Linear probing</li>
<li>Double hashing</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/03/Hash-Table/" data-id="cl2secust00031wtrftridsxz" data-title="Hash Table" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Dynamic-Programming" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/03/Dynamic-Programming/" class="article-date">
  <time class="dt-published" datetime="2022-05-02T18:06:12.000Z" itemprop="datePublished">2022-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/03/Dynamic-Programming/">Dynamic Programming</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/03/Dynamic-Programming/" data-id="cl2secusf00001wtr7qk7cw4l" data-title="Dynamic Programming" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming-Paradigm/" rel="tag">Programming Paradigm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Theory/" rel="tag">Theory</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Graph-Algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/Graph-Algorithm/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T04:04:38.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/Graph-Algorithm/">Graph Algorithm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>Ideology of DFS search is to dig as deep as it goes. It normally implemented using recursion, can using stack to improve it’s performance. It will also generate <strong>DFS forest</strong>, which will be a group of trees in the graph, each indicate a connected component. </p>
<p>The performance of DFS search normally is O(V + E) or O(V^2) as it inspect each vertex at most once. </p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>Ideology of BFS is to visit the neighbour in a consistent fashion. This algorithm is useful for path finding as it garunteed the shortest path in undirected graph. </p>
<p>The performance of DFS search normally is O(V + E) or O(V^2) as it inspect each vertex at most once. </p>
<h2 id="Cycle-Detection"><a href="#Cycle-Detection" class="headerlink" title="Cycle Detection"></a>Cycle Detection</h2><p>Cycle detection is a basic problem. It normally implemented using DFS search, the maths behind it is </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G has a cycle  &lt;=&gt;  G has a back edge</span><br></pre></td></tr></table></figure>

<p>Along construction of DFS forest, back-edge is thoes edge that connect to the ancestor node that isn’t the parent. (When graph is directed graph, the cycle detection getting more tricky. <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/261573/best-algorithm-for-detecting-cycles-in-a-directed-graph">https://stackoverflow.com/questions/261573/best-algorithm-for-detecting-cycles-in-a-directed-graph</a>) </p>
<p>The general algorithm for undirected graph would be </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool isDAGHelper(Graph g, int v, int p, int *visit, int size) &#123;</span><br><span class="line">	// Modify visit status</span><br><span class="line">	visit[v] = 1;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (GraphIsAdjacent(g, v, i) == <span class="literal">true</span> &amp;&amp; visit[i] == 0) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isDAGHelper(g, i, v,visit, size) == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (GraphIsAdjacent(g, v, i) == <span class="literal">true</span> &amp;&amp; i != p) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool hasCycle(Graph g) &#123;</span><br><span class="line">	int size = GraphNumVertices(g);</span><br><span class="line">	int *visit = calloc(size + 1, sizeof(int));</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    // When the graph is directed, this algorithm wont work because the back edge it detecting may be a cross edge</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (visit[i] == 0 &amp;&amp; isDAGHelper(g, i, i,visit, size) == <span class="literal">true</span>) &#123;</span><br><span class="line">			free(visit);</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	free(visit);</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Connected-Component"><a href="#Connected-Component" class="headerlink" title="Connected Component"></a>Connected Component</h2><h2 id="Hamiltonian-path-and-circuit"><a href="#Hamiltonian-path-and-circuit" class="headerlink" title="Hamiltonian path and circuit"></a>Hamiltonian path and circuit</h2><h2 id="Euler-path-and-circuit"><a href="#Euler-path-and-circuit" class="headerlink" title="Euler path and circuit"></a>Euler path and circuit</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/Graph-Algorithm/" data-id="cl2inrees0003h4trh0013ter" data-title="Graph Algorithm" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DFS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/DFS/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T03:57:23.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/DFS/">DFS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>I am pretty good at DFS, so i will keep this part empty.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/DFS/" data-id="cl2inreel0000h4tr5iqz2jt8" data-title="DFS" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-BFS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/BFS/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T03:40:35.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/BFS/">BFS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Algorithm-of-BFS-search"><a href="#Algorithm-of-BFS-search" class="headerlink" title="Algorithm of BFS search"></a>Algorithm of BFS search</h2><p>Given a graph G(V, E), the edges of given vertice v, is adj[v].</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// This algorithm construct a BFS tree</span><br><span class="line">// Color represented</span><br><span class="line">//  1. Wite, undiscovered</span><br><span class="line">//  2. Gret, discovered but uninspected</span><br><span class="line">//  3. Black, discovered and inspected</span><br><span class="line">// u.d store the distance from s to u</span><br><span class="line">// u.pi store the parent of u : defined as the node discovered u</span><br><span class="line">BFS(G, s)</span><br><span class="line">    // Initialize all node to white (undiscovered)</span><br><span class="line">    <span class="keyword">for</span> each vertex u belong G.V - &#123; s &#125;</span><br><span class="line">        u.color = white</span><br><span class="line">        u.d = infinity</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    </span><br><span class="line">    // Discovered s</span><br><span class="line">    s.color = gret</span><br><span class="line">    s.d = 0</span><br><span class="line">    s.pi = NIL</span><br><span class="line"></span><br><span class="line">    // Create queue (include as discover process)</span><br><span class="line">    Q = empty</span><br><span class="line">    enqueue(Q, s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Q != empty </span><br><span class="line">        // Inspect front element</span><br><span class="line">        u = dequeue(Q)</span><br><span class="line">        <span class="keyword">for</span> each v belong to G.Adj[u]</span><br><span class="line">            // Disover the undiscovered vertice that are adjacent to u</span><br><span class="line">            <span class="keyword">if</span> v.color == white</span><br><span class="line">                v.color = grey</span><br><span class="line">                v.d = u.d + 1</span><br><span class="line">                v.pi = u </span><br><span class="line">                enqueue(v)</span><br><span class="line">        // Finish inspect u</span><br><span class="line">        u.color = black</span><br></pre></td></tr></table></figure>

<h4 id="Discussion-of-shortest-path"><a href="#Discussion-of-shortest-path" class="headerlink" title="Discussion of shortest path"></a>Discussion of shortest path</h4><p>Define shortest path as shortest path &lt;&#x3D; all exist path.</p>
<p>Lemma 22.1 Let G &#x3D; (V,E) be a directed or undirrected graph, let s belong to v be an arbitary vertex. Then for any edge(u,v) belong to E<br>            Shortest distance(s, v) &lt;&#x3D; Shortest distance(s, u) + 1.   (1)</p>
<p>Proof:<br>    Suppose v is reachtable from S, then there are total two cases<br>        1. There exist shorter path from s to u, else than through v. Then choose this path. (1) hold.<br>        2. There do not exist shorter path, or path else than through v. Choose path to v, and edge(v,u). (1) hold</p>
<p>Lemma 22.2 Let G &#x3D; (V,E) be a directed or undirrected graph, and suppose BFS is run on G from a given source vertex s belong V. Then upon termination,<br>            each vertice, v.d &gt;&#x3D; shortest path(s, v)</p>
<p>At first, v.d do not necessarly represent distance, so one can not chaim it have to be smaller than path, at least require explaniation.<br>From the algorithm, each vertice must have a parent node, denote u, and v.d &#x3D; u.d + 1. Then, by trace parent vertice of each vertice, we can<br>draw a path from v to s, by property that each vertice must have a parent vertice. </p>
<p>This path is greater or equal to the shortest path.</p>
<p>Lemma 22.3 Suppose during the execution of BFS, the queue Q contain following vertex<br>            {v1, v2,…vr}, where v1 is the head of Q and vr is the tail<br>            Then, vr.d &lt;&#x3D; v1.d + 1 and vi.d &lt; vi+1.d.</p>
<pre><code>Proof by induction.
At begining of BFS, there is only s in queue. Hence statement is true.
Assuming the above holds, by dequeue v1, v2 become head. 
vi.d &lt; vi+1.d unaffected for now.
vr.d &lt;= v1.d + 1 &lt; = v2.d + 1. Hence it also hold.

Now consider 2 cases
    1. No adjacent vertex added, then the above obviously hold.
    2. Adjacent vertex u, added to the list.
        u.d = v1.d + 1. And vr.d &lt;= v1.d + 1 &lt;= u.d. Thus vi.d &lt; vi+1.d hold.
        u.d = v1.d + 1 &lt;= v2.d + 1. Thus vr.d &lt; vi+1.d hold
</code></pre>
<p>Collorary 22.4<br>If vi enqueue early than vj, the v1.d &lt;&#x3D; vj.d.</p>
<p>Theorem 22.5<br>BFS search always produce shortest path.<br>During the BFS search, from s, for every other node blong G(V, E) have property<br>    v.d &#x3D; shortest path(s, v)</p>
<p>Prove by contradiction. Suppose there exist a node v such that<br>    v.d !&#x3D; shortest path(s, v).</p>
<p>By lemma 22.1, we know v.d &gt;&#x3D; shortest path(s, v), then we can deduce v.d &gt; shortrest path(s,v).<br>Vertex v have to be reachtable, else both infinity.<br>Because it is reachtable, consider the parent node of v, denote u that have preceding shortest path, discussed in lemma 22.2<br>we have shortest path(s,v) &#x3D; shortest path(s, u) + 1,<br>Then we have<br>v.d &gt; sd(s,v) &#x3D; sd(s, u) + 1 &#x3D; u.d + 1. </p>
<p>Then, consider the v’s color when u have being dequeue.<br>It either be white (undiscovered)<br>    then we know v.d &#x3D; u.d + 1. Contradiction.<br>If v is black,<br>    then it enqueue before u, v.d &lt;&#x3D; u.d. Contradiction, discussed above, in order to contradict the theorem, v.d &gt; sd(s, d), thus also greater than u.d + 1.<br>If v is gray,<br>    then it painted before dequeue u, painted by the vertex  denoted by w. And w is enqueue before u, so w.d &lt;&#x3D; u.d, and v.d &#x3D; w.d + 1 &lt;&#x3D; u.d + 1.<br>    Again by analysis, it have to be greater than u.d + 1. Hence contradiction&#x2F;</p>
<p>Thus, we conclude for all vertice v, after BFS(s, v), v.d is the sd(s, v). And we can obatin a shortest path from s to v.parent, and by repeat this process.</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>Enqueue, dequeue takes O(1), so the time devoted for dequeueing and enququeing takes O(V). Because BFS require scan each vertex at most one time, then for adjency list it would be O(E) and adjency matrix would be O(V^2). So the total running time would be O(V + E) or O(V + V^2) depend on the implementation. For dense graph, it’s O(E) for both implementation, for dense graph adjency list will be slightly better. </p>
<h2 id="BFS-tree"><a href="#BFS-tree" class="headerlink" title="BFS tree"></a>BFS tree</h2><p>Assume original graph G(V, E)<br>then by BFS search, we will get<br>    G(Gpi, Epi).<br>    where Vp &#x3D; {v : v.pi !&#x3D; Nil} &amp;&amp; {s} &#x2F;&#x2F; This will eliminate node not reachtable<br>    Epi {v.pi, v: v belong vp}          &#x2F;&#x2F; Include all edges that are linked</p>
<p>Gpi is a BFT, the shortest path in this curve from s to any v will also be shortest path from s to v.<br>And abs(E) &#x3D; abs(V) - 1, this is preserved from tree property. </p>
<p>Lemma BFS result a BFT. (No comments needed for this one)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/BFS/" data-id="cl2ih4atr0000w4trhvkqhp1c" data-title="BFS" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Tries-Radix-tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/Tries-Radix-tree/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T01:33:07.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/Tries-Radix-tree/">Tries (Radix tree)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tries"><a href="#Tries" class="headerlink" title="Tries"></a>Tries</h2><p>One property observe for the tree is that for different permutation of record, the shape of BST would differ with extreme case that BST become a linked list. This is called <strong>object space decomposition</strong>, because it’s decompositiuon of key range is driven by the object.  </p>
<p>An alternative to object space decomposition is to predefine the spliting position. So that the tree’s insertion patteren will be independent from the value, order of inserting item. This technique is called <strong>key space decomposition</strong>.</p>
<ol>
<li>This won’t garunteed the tree to be balanced.</li>
<li>The depth of tree will be fixed. (If know the range of data)</li>
<li>The value stored in the leave.</li>
</ol>
<p>A data structure based on key space decomposition is called <strong>tries</strong>. Huffman coding tree would an example of a <strong>binary tries</strong>. </p>
<h2 id="Alphabet-tries"><a href="#Alphabet-tries" class="headerlink" title="Alphabet tries"></a>Alphabet tries</h2><p>The tries we refer normally refer to the alphabet tries. It split using character in string. One application would be dictionary,  once constructed it used to determine if a given work is in dictionary.</p>
<p>Cost analysis</p>
<ul>
<li>O(n) space if linked list, O(k*m) if using array</li>
<li>O(m) insertion and search<br>for n total size of text<br>for m length of key string<br>for d size of underling alphabet</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdbool.h&gt;</span></span><br><span class="line"> </span><br><span class="line">// Define the character size</span><br><span class="line"><span class="comment">#define CHAR_SIZE 26</span></span><br><span class="line"> </span><br><span class="line">// Data structure to store a Trie node</span><br><span class="line">struct Trie &#123;</span><br><span class="line">    char currChar;</span><br><span class="line">    bool finish;</span><br><span class="line">    struct Trie* character[CHAR_SIZE];</span><br><span class="line">    // And <span class="keyword">if</span> the tries is finish, you might want to store an additional attribute</span><br><span class="line">    // Such as <span class="keyword">if</span> the string is a name, this can be an ID</span><br><span class="line">    // If tries want to count the word, this can be used to store an int count</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// Function that returns a new Trie node</span><br><span class="line">struct Trie* <span class="function"><span class="title">getNewTrieNode</span></span>() &#123;</span><br><span class="line">    struct Trie* newT = malloc(sizeof(*newT));</span><br><span class="line">    newT-&gt;currChar = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    newT-&gt;finish = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; CHAR_SIZE;i++) &#123;</span><br><span class="line">        newT-&gt;character[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> newT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Using recursive approach</span><br><span class="line">struct Trie* insertHelper(struct Trie *<span class="built_in">head</span>, char* str, int index, int size) &#123;</span><br><span class="line">    // Create node <span class="keyword">if</span> <span class="built_in">head</span> <span class="built_in">id</span> empty</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span> == NULL) &#123;</span><br><span class="line">        <span class="built_in">head</span> = getNewTrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Insert character</span><br><span class="line">    <span class="built_in">head</span>-&gt;currChar = str[index];</span><br><span class="line">    index++;</span><br><span class="line"></span><br><span class="line">    // Check <span class="keyword">if</span> str ended</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="built_in">head</span>-&gt;finish = <span class="literal">true</span>;</span><br><span class="line">    &#125; // Going to next loop</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">head</span>-&gt;character[str[index] - <span class="string">&#x27;a&#x27;</span>] = insertHelper(<span class="built_in">head</span>-&gt;character[str[index] - <span class="string">&#x27;a&#x27;</span>], str, index, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">head</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">struct Trie *insert(struct Trie *<span class="built_in">head</span>, char* str) &#123;</span><br><span class="line">    <span class="built_in">head</span>-&gt;character[str[0] - <span class="string">&#x27;a&#x27;</span>] = insertHelper(<span class="built_in">head</span>-&gt;character[str[0] - <span class="string">&#x27;a&#x27;</span>], str, 0, strlen(str));</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">head</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Similar recursive approach</span><br><span class="line">bool searchHelper(struct Trie *<span class="built_in">head</span>, char* str, int index, int size) &#123;</span><br><span class="line">    // If current <span class="built_in">head</span> <span class="keyword">do</span> not exist</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span> == NULL) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Compare the word</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span>-&gt;currChar != str[index]) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    index++;</span><br><span class="line">    // Check <span class="keyword">if</span> letter finish</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">head</span>-&gt;finish == <span class="literal">true</span>) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; // Recursively search <span class="keyword">for</span> the next character</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> searchHelper(<span class="built_in">head</span>-&gt;character[str[index] - <span class="string">&#x27;a&#x27;</span>], str, index, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">bool search(struct Trie* <span class="built_in">head</span>, char* str) &#123;</span><br><span class="line">    <span class="built_in">return</span> searchHelper(<span class="built_in">head</span>-&gt;character[str[0] - <span class="string">&#x27;a&#x27;</span>], str, 0, strlen(str));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Returns 1 <span class="keyword">if</span> a given Trie node has any children</span><br><span class="line">bool hasChildren(struct Trie* curr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; CHAR_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;character[i] != NULL) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// str need to have enough space</span><br><span class="line">void printTriesHelper(struct Trie *root, char *str) &#123;</span><br><span class="line">    // Base <span class="keyword">case</span></span><br><span class="line">    <span class="keyword">if</span> (root == NULL) <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">    // recursive <span class="keyword">case</span></span><br><span class="line">    // add current char to the root</span><br><span class="line">    int size = strlen(str);</span><br><span class="line">    str[size] = root-&gt;currChar;</span><br><span class="line">    str[size + 1] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    // If string finish here</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;finish == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    // Then recursive visit children from this position</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; CHAR_SIZE; i++) &#123;</span><br><span class="line">        printTriesHelper(root-&gt;character[i], str);</span><br><span class="line">    &#125;</span><br><span class="line">    // After visit each node, one is responsible <span class="keyword">for</span> erase the char last accessed</span><br><span class="line">    str[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printTries(struct Trie *root, char *str) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; CHAR_SIZE; i++) &#123;</span><br><span class="line">        printTriesHelper(root-&gt;character[i], str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Recursive <span class="keyword">function</span> to delete a string from a Trie</span><br><span class="line">void deletionHelper(struct Trie *<span class="built_in">head</span>, char* str, int index, int size) &#123;</span><br><span class="line">    // Create node <span class="keyword">if</span> <span class="built_in">head</span> <span class="built_in">id</span> empty</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span> == NULL) <span class="built_in">return</span>;</span><br><span class="line">    // <span class="keyword">if</span> the character <span class="keyword">if</span> not matching</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span>-&gt;currChar != str[index]) <span class="built_in">return</span>;</span><br><span class="line">    index++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="built_in">head</span>-&gt;finish = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deletionHelper(<span class="built_in">head</span>-&gt;character[str[index] - <span class="string">&#x27;a&#x27;</span>], str, index, size);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void deletion(struct Trie *curr, char* str) &#123;</span><br><span class="line">    deletionHelper(curr-&gt;character[str[0] - <span class="string">&#x27;a&#x27;</span>], str, 0, strlen(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// Trie implementation <span class="keyword">in</span> C – Insertion, Searching, and Deletion</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    struct Trie* <span class="built_in">head</span> = getNewTrieNode();</span><br><span class="line"> </span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (search(<span class="built_in">head</span>, <span class="string">&quot;hello&quot;</span>) == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;hey&quot;</span>);</span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;no&quot;</span>);</span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;bro&quot;</span>);</span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;hey&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    char *inspect = malloc(1024);</span><br><span class="line">    inspect[0] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    printTries(<span class="built_in">head</span>, inspect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/Tries-Radix-tree/" data-id="cl2if0zg70000q4trahvcgrsm" data-title="Tries (Radix tree)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2-3-4-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/2-3-4-Tree/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T01:10:34.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/2-3-4-Tree/">2-3-4 Tree</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/2-3-4-Tree/" data-id="cl2ib8q8v00008str7zunf48b" data-title="2-3-4 Tree" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AVL-tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/AVL-tree/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T01:01:01.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/AVL-tree/">AVL tree</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h2><p>Analysis of AVL trees:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. trees are height-balanced; subtree depths differ by +/-1</span><br><span class="line">2. average/worst-case search performance of O(<span class="built_in">log</span> n)</span><br><span class="line">3. require extra data to be stored <span class="keyword">in</span> each node (efficiency)</span><br><span class="line">4. require extra data to be maintained during insertion</span><br><span class="line">5. may not be weight-balanced; subtree sizes may differ</span><br></pre></td></tr></table></figure>

<p>Insertion</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BSTree insert(BSTree t, int value) &#123;</span><br><span class="line">	<span class="keyword">if</span> (t == NULL) &#123;</span><br><span class="line">		<span class="built_in">return</span> createNode(value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;value == value)&#123;</span><br><span class="line">		<span class="built_in">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		int cmp = t-&gt;value - value;</span><br><span class="line">		<span class="keyword">if</span> (cmp &gt; 0) &#123;</span><br><span class="line">			t-&gt;left = insert(t-&gt;left, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			t-&gt;right = insert(t-&gt;right, value);</span><br><span class="line">		&#125;</span><br><span class="line">		int lheight = BSTreeHeight(t-&gt;left);</span><br><span class="line">        int rheight = BSTreeHeight(t-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> ((lheight - rheight) &gt; 1) &#123;</span><br><span class="line">            // If element inserted at the right branch of left child of node</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left-&gt;value - value &lt; 0) &#123;</span><br><span class="line">                t-&gt;left = leftRotation(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            t = rightRotation(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rheight - lheight) &gt; 1) &#123;</span><br><span class="line">            // If element inserted at the left branch of right child of node</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right-&gt;value - value &gt; 0) &#123;</span><br><span class="line">                t-&gt;right = rightRotation(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            t = leftRotation(t);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/AVL-tree/" data-id="cl2iawkzt0000y4trhiepaeje" data-title="AVL tree" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/COMP2521/">COMP2521</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ADT/" rel="tag">ADT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COMP2521/" rel="tag">COMP2521</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Language/" rel="tag">Language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Personal/" rel="tag">Personal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programming-Paradigm/" rel="tag">Programming Paradigm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Report/" rel="tag">Report</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sorting/" rel="tag">Sorting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Theory/" rel="tag">Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ADT/" style="font-size: 12.5px;">ADT</a> <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/COMP2521/" style="font-size: 15px;">COMP2521</a> <a href="/tags/Data-Structure/" style="font-size: 20px;">Data Structure</a> <a href="/tags/Graph/" style="font-size: 15px;">Graph</a> <a href="/tags/Language/" style="font-size: 10px;">Language</a> <a href="/tags/Personal/" style="font-size: 10px;">Personal</a> <a href="/tags/Programming-Paradigm/" style="font-size: 10px;">Programming Paradigm</a> <a href="/tags/Report/" style="font-size: 10px;">Report</a> <a href="/tags/Sorting/" style="font-size: 10px;">Sorting</a> <a href="/tags/Theory/" style="font-size: 15px;">Theory</a> <a href="/tags/Tree/" style="font-size: 17.5px;">Tree</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/06/NodesNotInCycle/">NodesNotInCycle</a>
          </li>
        
          <li>
            <a href="/2022/05/04/Things-I-know-so-far/">Things I know so far</a>
          </li>
        
          <li>
            <a href="/2022/05/03/Hash-Table/">Hash Table</a>
          </li>
        
          <li>
            <a href="/2022/05/03/Dynamic-Programming/">Dynamic Programming</a>
          </li>
        
          <li>
            <a href="/2022/04/28/Graph-Algorithm/">Graph Algorithm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
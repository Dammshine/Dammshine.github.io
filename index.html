<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Things-I-know-so-far" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/04/Things-I-know-so-far/" class="article-date">
  <time class="dt-published" datetime="2022-05-04T03:15:46.000Z" itemprop="datePublished">2022-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/04/Things-I-know-so-far/">Things I know so far</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Data-structure"><a href="#Data-structure" class="headerlink" title="Data structure"></a>Data structure</h2><p>The data structure that I’ve met so far is pretty primitive, include a few advanced ones. It can be category as array and list, tree, graph. </p>
<h4 id="Array-and-list"><a href="#Array-and-list" class="headerlink" title="Array and list"></a>Array and list</h4><ol>
<li>Array<br> a. Array with circular implementation. It gives a one dimensional space felling.<br> b. 2-D array, used in many situation, for example will be the graph. Also used to implement matrix.<br> c. Heap, use an array. It can be also included in tree.<br> d. <strong>Rooted tree</strong>, using an array to represent a tree structure.</li>
<li>Linked list<br> a. Singly linked list, double linked list. List store head and tail.<br>The list is ideal to implement queue like structure. As itself looks like a queue.<br>The graph can also use linked list, for scarse diagram for ideal.<br> b. <strong>Skipped list</strong><br> c. <strong>Sqrt list</strong><br> d. Linked list contains parent pointer can be used to implement <strong>disjoint set</strong></li>
</ol>
<p>I should take time to visit chapter 12, data structure and algorithm in c++.</p>
<h4 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h4><ol>
<li>Binary Tree<br> a. Binary search tree. Ideal for store element, search element.<br> b. Self balanced tree. Build upon binary tree, can garunteed the maximum search cost within boundary,<br>by the cost of coefficient and extra memory<br>1. <strong>Red Black tree</strong><br>2. AVL tree</li>
<li>Non-binary tree<br> a. 2-3-4 Tree. B tree.<br> b. <strong>rooted tree</strong></li>
<li>Tries<br> All above tree like structure uses, object space decomposition, tries uses key space decomposition.<br> a. Alaphabet tries. To find duplicate words, or count words.<br> b. Huffman coding tree. To compress info.</li>
<li><strong>Spatial Data structure</strong><br> a. K-D tree<br> b. PR quadtree</li>
</ol>
<h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><ol>
<li>Implementation would just be adjency list, adjency matrix and array of edges.<br>But the more important things would be<ol>
<li>SSSP problem <ul>
<li>Dijistra’s algorithm</li>
</ul>
</li>
<li>ASSP problem<ul>
<li>Floyd-warshall</li>
<li>Johnson</li>
</ul>
</li>
<li>MST<ul>
<li>Prim</li>
<li>Kruskal</li>
</ul>
</li>
<li>Max-flow</li>
</ol>
</li>
</ol>
<h4 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h4><p>Three different resolution</p>
<ol>
<li>Chaining</li>
<li>Linear probing</li>
<li>Double hashing<br>The last two can also be classify as category Open Addressing.</li>
</ol>
<p>Hash function</p>
<h4 id="Ideology"><a href="#Ideology" class="headerlink" title="Ideology"></a>Ideology</h4><ol>
<li>Divide and conquer</li>
<li>Randomise algorithm</li>
<li>DP</li>
<li>Greedy</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/04/Things-I-know-so-far/" data-id="cl2secusm00011wtr74de71b7" data-title="Things I know so far" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Personal/" rel="tag">Personal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Report/" rel="tag">Report</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Hash-Table" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/03/Hash-Table/" class="article-date">
  <time class="dt-published" datetime="2022-05-03T03:51:13.000Z" itemprop="datePublished">2022-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/03/Hash-Table/">Hash Table</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Type of Hash Table</p>
<ol>
<li>Chaining<br> 1. </li>
<li>Linear probing</li>
<li>Double hashing</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/03/Hash-Table/" data-id="cl2secust00031wtrftridsxz" data-title="Hash Table" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Dynamic-Programming" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/03/Dynamic-Programming/" class="article-date">
  <time class="dt-published" datetime="2022-05-02T18:06:12.000Z" itemprop="datePublished">2022-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/03/Dynamic-Programming/">Dynamic Programming</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/03/Dynamic-Programming/" data-id="cl2secusf00001wtr7qk7cw4l" data-title="Dynamic Programming" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming-Paradigm/" rel="tag">Programming Paradigm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Theory/" rel="tag">Theory</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Graph-Algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/Graph-Algorithm/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T04:04:38.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/Graph-Algorithm/">Graph Algorithm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>Ideology of DFS search is to dig as deep as it goes. It normally implemented using recursion, can using stack to improve it’s performance. It will also generate <strong>DFS forest</strong>, which will be a group of trees in the graph, each indicate a connected component. </p>
<p>The performance of DFS search normally is O(V + E) or O(V^2) as it inspect each vertex at most once. </p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>Ideology of BFS is to visit the neighbour in a consistent fashion. This algorithm is useful for path finding as it garunteed the shortest path in undirected graph. </p>
<p>The performance of DFS search normally is O(V + E) or O(V^2) as it inspect each vertex at most once. </p>
<h2 id="Cycle-Detection"><a href="#Cycle-Detection" class="headerlink" title="Cycle Detection"></a>Cycle Detection</h2><p>Cycle detection is a basic problem. It normally implemented using DFS search, the maths behind it is </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G has a cycle  &lt;=&gt;  G has a back edge</span><br></pre></td></tr></table></figure>

<p>Along construction of DFS forest, back-edge is thoes edge that connect to the ancestor node that isn’t the parent. (When graph is directed graph, the cycle detection getting more tricky. <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/261573/best-algorithm-for-detecting-cycles-in-a-directed-graph">https://stackoverflow.com/questions/261573/best-algorithm-for-detecting-cycles-in-a-directed-graph</a>) </p>
<p>The general algorithm for undirected graph would be </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool isDAGHelper(Graph g, int v, int p, int *visit, int size) &#123;</span><br><span class="line">	// Modify visit status</span><br><span class="line">	visit[v] = 1;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (GraphIsAdjacent(g, v, i) == <span class="literal">true</span> &amp;&amp; visit[i] == 0) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isDAGHelper(g, i, v,visit, size) == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (GraphIsAdjacent(g, v, i) == <span class="literal">true</span> &amp;&amp; i != p) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool hasCycle(Graph g) &#123;</span><br><span class="line">	int size = GraphNumVertices(g);</span><br><span class="line">	int *visit = calloc(size + 1, sizeof(int));</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    // When the graph is directed, this algorithm wont work because the back edge it detecting may be a cross edge</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (visit[i] == 0 &amp;&amp; isDAGHelper(g, i, i,visit, size) == <span class="literal">true</span>) &#123;</span><br><span class="line">			free(visit);</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	free(visit);</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Connected-Component"><a href="#Connected-Component" class="headerlink" title="Connected Component"></a>Connected Component</h2><h2 id="Hamiltonian-path-and-circuit"><a href="#Hamiltonian-path-and-circuit" class="headerlink" title="Hamiltonian path and circuit"></a>Hamiltonian path and circuit</h2><h2 id="Euler-path-and-circuit"><a href="#Euler-path-and-circuit" class="headerlink" title="Euler path and circuit"></a>Euler path and circuit</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/Graph-Algorithm/" data-id="cl2inrees0003h4trh0013ter" data-title="Graph Algorithm" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DFS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/DFS/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T03:57:23.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/DFS/">DFS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>I am pretty good at DFS, so i will keep this part empty.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/DFS/" data-id="cl2inreel0000h4tr5iqz2jt8" data-title="DFS" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-BFS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/BFS/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T03:40:35.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/BFS/">BFS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Algorithm-of-BFS-search"><a href="#Algorithm-of-BFS-search" class="headerlink" title="Algorithm of BFS search"></a>Algorithm of BFS search</h2><p>Given a graph G(V, E), the edges of given vertice v, is adj[v].</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// This algorithm construct a BFS tree</span><br><span class="line">// Color represented</span><br><span class="line">//  1. Wite, undiscovered</span><br><span class="line">//  2. Gret, discovered but uninspected</span><br><span class="line">//  3. Black, discovered and inspected</span><br><span class="line">// u.d store the distance from s to u</span><br><span class="line">// u.pi store the parent of u : defined as the node discovered u</span><br><span class="line">BFS(G, s)</span><br><span class="line">    // Initialize all node to white (undiscovered)</span><br><span class="line">    <span class="keyword">for</span> each vertex u belong G.V - &#123; s &#125;</span><br><span class="line">        u.color = white</span><br><span class="line">        u.d = infinity</span><br><span class="line">        u.pi = NIL</span><br><span class="line">    </span><br><span class="line">    // Discovered s</span><br><span class="line">    s.color = gret</span><br><span class="line">    s.d = 0</span><br><span class="line">    s.pi = NIL</span><br><span class="line"></span><br><span class="line">    // Create queue (include as discover process)</span><br><span class="line">    Q = empty</span><br><span class="line">    enqueue(Q, s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> Q != empty </span><br><span class="line">        // Inspect front element</span><br><span class="line">        u = dequeue(Q)</span><br><span class="line">        <span class="keyword">for</span> each v belong to G.Adj[u]</span><br><span class="line">            // Disover the undiscovered vertice that are adjacent to u</span><br><span class="line">            <span class="keyword">if</span> v.color == white</span><br><span class="line">                v.color = grey</span><br><span class="line">                v.d = u.d + 1</span><br><span class="line">                v.pi = u </span><br><span class="line">                enqueue(v)</span><br><span class="line">        // Finish inspect u</span><br><span class="line">        u.color = black</span><br></pre></td></tr></table></figure>

<h4 id="Discussion-of-shortest-path"><a href="#Discussion-of-shortest-path" class="headerlink" title="Discussion of shortest path"></a>Discussion of shortest path</h4><p>Define shortest path as shortest path &lt;&#x3D; all exist path.</p>
<p>Lemma 22.1 Let G &#x3D; (V,E) be a directed or undirrected graph, let s belong to v be an arbitary vertex. Then for any edge(u,v) belong to E<br>            Shortest distance(s, v) &lt;&#x3D; Shortest distance(s, u) + 1.   (1)</p>
<p>Proof:<br>    Suppose v is reachtable from S, then there are total two cases<br>        1. There exist shorter path from s to u, else than through v. Then choose this path. (1) hold.<br>        2. There do not exist shorter path, or path else than through v. Choose path to v, and edge(v,u). (1) hold</p>
<p>Lemma 22.2 Let G &#x3D; (V,E) be a directed or undirrected graph, and suppose BFS is run on G from a given source vertex s belong V. Then upon termination,<br>            each vertice, v.d &gt;&#x3D; shortest path(s, v)</p>
<p>At first, v.d do not necessarly represent distance, so one can not chaim it have to be smaller than path, at least require explaniation.<br>From the algorithm, each vertice must have a parent node, denote u, and v.d &#x3D; u.d + 1. Then, by trace parent vertice of each vertice, we can<br>draw a path from v to s, by property that each vertice must have a parent vertice. </p>
<p>This path is greater or equal to the shortest path.</p>
<p>Lemma 22.3 Suppose during the execution of BFS, the queue Q contain following vertex<br>            {v1, v2,…vr}, where v1 is the head of Q and vr is the tail<br>            Then, vr.d &lt;&#x3D; v1.d + 1 and vi.d &lt; vi+1.d.</p>
<pre><code>Proof by induction.
At begining of BFS, there is only s in queue. Hence statement is true.
Assuming the above holds, by dequeue v1, v2 become head. 
vi.d &lt; vi+1.d unaffected for now.
vr.d &lt;= v1.d + 1 &lt; = v2.d + 1. Hence it also hold.

Now consider 2 cases
    1. No adjacent vertex added, then the above obviously hold.
    2. Adjacent vertex u, added to the list.
        u.d = v1.d + 1. And vr.d &lt;= v1.d + 1 &lt;= u.d. Thus vi.d &lt; vi+1.d hold.
        u.d = v1.d + 1 &lt;= v2.d + 1. Thus vr.d &lt; vi+1.d hold
</code></pre>
<p>Collorary 22.4<br>If vi enqueue early than vj, the v1.d &lt;&#x3D; vj.d.</p>
<p>Theorem 22.5<br>BFS search always produce shortest path.<br>During the BFS search, from s, for every other node blong G(V, E) have property<br>    v.d &#x3D; shortest path(s, v)</p>
<p>Prove by contradiction. Suppose there exist a node v such that<br>    v.d !&#x3D; shortest path(s, v).</p>
<p>By lemma 22.1, we know v.d &gt;&#x3D; shortest path(s, v), then we can deduce v.d &gt; shortrest path(s,v).<br>Vertex v have to be reachtable, else both infinity.<br>Because it is reachtable, consider the parent node of v, denote u that have preceding shortest path, discussed in lemma 22.2<br>we have shortest path(s,v) &#x3D; shortest path(s, u) + 1,<br>Then we have<br>v.d &gt; sd(s,v) &#x3D; sd(s, u) + 1 &#x3D; u.d + 1. </p>
<p>Then, consider the v’s color when u have being dequeue.<br>It either be white (undiscovered)<br>    then we know v.d &#x3D; u.d + 1. Contradiction.<br>If v is black,<br>    then it enqueue before u, v.d &lt;&#x3D; u.d. Contradiction, discussed above, in order to contradict the theorem, v.d &gt; sd(s, d), thus also greater than u.d + 1.<br>If v is gray,<br>    then it painted before dequeue u, painted by the vertex  denoted by w. And w is enqueue before u, so w.d &lt;&#x3D; u.d, and v.d &#x3D; w.d + 1 &lt;&#x3D; u.d + 1.<br>    Again by analysis, it have to be greater than u.d + 1. Hence contradiction&#x2F;</p>
<p>Thus, we conclude for all vertice v, after BFS(s, v), v.d is the sd(s, v). And we can obatin a shortest path from s to v.parent, and by repeat this process.</p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>Enqueue, dequeue takes O(1), so the time devoted for dequeueing and enququeing takes O(V). Because BFS require scan each vertex at most one time, then for adjency list it would be O(E) and adjency matrix would be O(V^2). So the total running time would be O(V + E) or O(V + V^2) depend on the implementation. For dense graph, it’s O(E) for both implementation, for dense graph adjency list will be slightly better. </p>
<h2 id="BFS-tree"><a href="#BFS-tree" class="headerlink" title="BFS tree"></a>BFS tree</h2><p>Assume original graph G(V, E)<br>then by BFS search, we will get<br>    G(Gpi, Epi).<br>    where Vp &#x3D; {v : v.pi !&#x3D; Nil} &amp;&amp; {s} &#x2F;&#x2F; This will eliminate node not reachtable<br>    Epi {v.pi, v: v belong vp}          &#x2F;&#x2F; Include all edges that are linked</p>
<p>Gpi is a BFT, the shortest path in this curve from s to any v will also be shortest path from s to v.<br>And abs(E) &#x3D; abs(V) - 1, this is preserved from tree property. </p>
<p>Lemma BFS result a BFT. (No comments needed for this one)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/BFS/" data-id="cl2ih4atr0000w4trhvkqhp1c" data-title="BFS" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Tries-Radix-tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/Tries-Radix-tree/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T01:33:07.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/Tries-Radix-tree/">Tries (Radix tree)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Tries"><a href="#Tries" class="headerlink" title="Tries"></a>Tries</h2><p>One property observe for the tree is that for different permutation of record, the shape of BST would differ with extreme case that BST become a linked list. This is called <strong>object space decomposition</strong>, because it’s decompositiuon of key range is driven by the object.  </p>
<p>An alternative to object space decomposition is to predefine the spliting position. So that the tree’s insertion patteren will be independent from the value, order of inserting item. This technique is called <strong>key space decomposition</strong>.</p>
<ol>
<li>This won’t garunteed the tree to be balanced.</li>
<li>The depth of tree will be fixed. (If know the range of data)</li>
<li>The value stored in the leave.</li>
</ol>
<p>A data structure based on key space decomposition is called <strong>tries</strong>. Huffman coding tree would an example of a <strong>binary tries</strong>. </p>
<h2 id="Alphabet-tries"><a href="#Alphabet-tries" class="headerlink" title="Alphabet tries"></a>Alphabet tries</h2><p>The tries we refer normally refer to the alphabet tries. It split using character in string. One application would be dictionary,  once constructed it used to determine if a given work is in dictionary.</p>
<p>Cost analysis</p>
<ul>
<li>O(n) space if linked list, O(k*m) if using array</li>
<li>O(m) insertion and search<br>for n total size of text<br>for m length of key string<br>for d size of underling alphabet</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdbool.h&gt;</span></span><br><span class="line"> </span><br><span class="line">// Define the character size</span><br><span class="line"><span class="comment">#define CHAR_SIZE 26</span></span><br><span class="line"> </span><br><span class="line">// Data structure to store a Trie node</span><br><span class="line">struct Trie &#123;</span><br><span class="line">    char currChar;</span><br><span class="line">    bool finish;</span><br><span class="line">    struct Trie* character[CHAR_SIZE];</span><br><span class="line">    // And <span class="keyword">if</span> the tries is finish, you might want to store an additional attribute</span><br><span class="line">    // Such as <span class="keyword">if</span> the string is a name, this can be an ID</span><br><span class="line">    // If tries want to count the word, this can be used to store an int count</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// Function that returns a new Trie node</span><br><span class="line">struct Trie* <span class="function"><span class="title">getNewTrieNode</span></span>() &#123;</span><br><span class="line">    struct Trie* newT = malloc(sizeof(*newT));</span><br><span class="line">    newT-&gt;currChar = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    newT-&gt;finish = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; CHAR_SIZE;i++) &#123;</span><br><span class="line">        newT-&gt;character[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> newT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Using recursive approach</span><br><span class="line">struct Trie* insertHelper(struct Trie *<span class="built_in">head</span>, char* str, int index, int size) &#123;</span><br><span class="line">    // Create node <span class="keyword">if</span> <span class="built_in">head</span> <span class="built_in">id</span> empty</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span> == NULL) &#123;</span><br><span class="line">        <span class="built_in">head</span> = getNewTrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Insert character</span><br><span class="line">    <span class="built_in">head</span>-&gt;currChar = str[index];</span><br><span class="line">    index++;</span><br><span class="line"></span><br><span class="line">    // Check <span class="keyword">if</span> str ended</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="built_in">head</span>-&gt;finish = <span class="literal">true</span>;</span><br><span class="line">    &#125; // Going to next loop</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">head</span>-&gt;character[str[index] - <span class="string">&#x27;a&#x27;</span>] = insertHelper(<span class="built_in">head</span>-&gt;character[str[index] - <span class="string">&#x27;a&#x27;</span>], str, index, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">head</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">struct Trie *insert(struct Trie *<span class="built_in">head</span>, char* str) &#123;</span><br><span class="line">    <span class="built_in">head</span>-&gt;character[str[0] - <span class="string">&#x27;a&#x27;</span>] = insertHelper(<span class="built_in">head</span>-&gt;character[str[0] - <span class="string">&#x27;a&#x27;</span>], str, 0, strlen(str));</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">head</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Similar recursive approach</span><br><span class="line">bool searchHelper(struct Trie *<span class="built_in">head</span>, char* str, int index, int size) &#123;</span><br><span class="line">    // If current <span class="built_in">head</span> <span class="keyword">do</span> not exist</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span> == NULL) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Compare the word</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span>-&gt;currChar != str[index]) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    index++;</span><br><span class="line">    // Check <span class="keyword">if</span> letter finish</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">head</span>-&gt;finish == <span class="literal">true</span>) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; // Recursively search <span class="keyword">for</span> the next character</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> searchHelper(<span class="built_in">head</span>-&gt;character[str[index] - <span class="string">&#x27;a&#x27;</span>], str, index, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">bool search(struct Trie* <span class="built_in">head</span>, char* str) &#123;</span><br><span class="line">    <span class="built_in">return</span> searchHelper(<span class="built_in">head</span>-&gt;character[str[0] - <span class="string">&#x27;a&#x27;</span>], str, 0, strlen(str));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Returns 1 <span class="keyword">if</span> a given Trie node has any children</span><br><span class="line">bool hasChildren(struct Trie* curr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; CHAR_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;character[i] != NULL) <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// str need to have enough space</span><br><span class="line">void printTriesHelper(struct Trie *root, char *str) &#123;</span><br><span class="line">    // Base <span class="keyword">case</span></span><br><span class="line">    <span class="keyword">if</span> (root == NULL) <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">    // recursive <span class="keyword">case</span></span><br><span class="line">    // add current char to the root</span><br><span class="line">    int size = strlen(str);</span><br><span class="line">    str[size] = root-&gt;currChar;</span><br><span class="line">    str[size + 1] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    // If string finish here</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;finish == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    // Then recursive visit children from this position</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; CHAR_SIZE; i++) &#123;</span><br><span class="line">        printTriesHelper(root-&gt;character[i], str);</span><br><span class="line">    &#125;</span><br><span class="line">    // After visit each node, one is responsible <span class="keyword">for</span> erase the char last accessed</span><br><span class="line">    str[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printTries(struct Trie *root, char *str) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; CHAR_SIZE; i++) &#123;</span><br><span class="line">        printTriesHelper(root-&gt;character[i], str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Recursive <span class="keyword">function</span> to delete a string from a Trie</span><br><span class="line">void deletionHelper(struct Trie *<span class="built_in">head</span>, char* str, int index, int size) &#123;</span><br><span class="line">    // Create node <span class="keyword">if</span> <span class="built_in">head</span> <span class="built_in">id</span> empty</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span> == NULL) <span class="built_in">return</span>;</span><br><span class="line">    // <span class="keyword">if</span> the character <span class="keyword">if</span> not matching</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">head</span>-&gt;currChar != str[index]) <span class="built_in">return</span>;</span><br><span class="line">    index++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        <span class="built_in">head</span>-&gt;finish = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deletionHelper(<span class="built_in">head</span>-&gt;character[str[index] - <span class="string">&#x27;a&#x27;</span>], str, index, size);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void deletion(struct Trie *curr, char* str) &#123;</span><br><span class="line">    deletionHelper(curr-&gt;character[str[0] - <span class="string">&#x27;a&#x27;</span>], str, 0, strlen(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// Trie implementation <span class="keyword">in</span> C – Insertion, Searching, and Deletion</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    struct Trie* <span class="built_in">head</span> = getNewTrieNode();</span><br><span class="line"> </span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (search(<span class="built_in">head</span>, <span class="string">&quot;hello&quot;</span>) == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;hey&quot;</span>);</span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;no&quot;</span>);</span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;bro&quot;</span>);</span><br><span class="line">    insert(<span class="built_in">head</span>, <span class="string">&quot;hey&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    char *inspect = malloc(1024);</span><br><span class="line">    inspect[0] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    printTries(<span class="built_in">head</span>, inspect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/Tries-Radix-tree/" data-id="cl2if0zg70000q4trahvcgrsm" data-title="Tries (Radix tree)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2-3-4-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/2-3-4-Tree/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T01:10:34.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/2-3-4-Tree/">2-3-4 Tree</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/2-3-4-Tree/" data-id="cl2ib8q8v00008str7zunf48b" data-title="2-3-4 Tree" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AVL-tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/28/AVL-tree/" class="article-date">
  <time class="dt-published" datetime="2022-04-28T01:01:01.000Z" itemprop="datePublished">2022-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/28/AVL-tree/">AVL tree</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h2><p>Analysis of AVL trees:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. trees are height-balanced; subtree depths differ by +/-1</span><br><span class="line">2. average/worst-case search performance of O(<span class="built_in">log</span> n)</span><br><span class="line">3. require extra data to be stored <span class="keyword">in</span> each node (efficiency)</span><br><span class="line">4. require extra data to be maintained during insertion</span><br><span class="line">5. may not be weight-balanced; subtree sizes may differ</span><br></pre></td></tr></table></figure>

<p>Insertion</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BSTree insert(BSTree t, int value) &#123;</span><br><span class="line">	<span class="keyword">if</span> (t == NULL) &#123;</span><br><span class="line">		<span class="built_in">return</span> createNode(value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;value == value)&#123;</span><br><span class="line">		<span class="built_in">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		int cmp = t-&gt;value - value;</span><br><span class="line">		<span class="keyword">if</span> (cmp &gt; 0) &#123;</span><br><span class="line">			t-&gt;left = insert(t-&gt;left, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			t-&gt;right = insert(t-&gt;right, value);</span><br><span class="line">		&#125;</span><br><span class="line">		int lheight = BSTreeHeight(t-&gt;left);</span><br><span class="line">        int rheight = BSTreeHeight(t-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> ((lheight - rheight) &gt; 1) &#123;</span><br><span class="line">            // If element inserted at the right branch of left child of node</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left-&gt;value - value &lt; 0) &#123;</span><br><span class="line">                t-&gt;left = leftRotation(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            t = rightRotation(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rheight - lheight) &gt; 1) &#123;</span><br><span class="line">            // If element inserted at the left branch of right child of node</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right-&gt;value - value &gt; 0) &#123;</span><br><span class="line">                t-&gt;right = rightRotation(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            t = leftRotation(t);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/28/AVL-tree/" data-id="cl2iawkzt0000y4trhiepaeje" data-title="AVL tree" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Sorting" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/27/Sorting/" class="article-date">
  <time class="dt-published" datetime="2022-04-26T19:51:47.000Z" itemprop="datePublished">2022-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/COMP2521/">COMP2521</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/27/Sorting/">Sorting</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="General-Property-of-Sorting"><a href="#General-Property-of-Sorting" class="headerlink" title="General Property of Sorting"></a>General Property of Sorting</h2><p><strong>Sorting problem</strong> is defined </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input  : A sequence of n numbers</span><br><span class="line">Output : A permutation of input such that <span class="keyword">for</span> each i <span class="keyword">in</span> array, a[i] &lt;= a[i+1].</span><br></pre></td></tr></table></figure>


<h4 id="Stable-x2F-unstable"><a href="#Stable-x2F-unstable" class="headerlink" title="Stable &#x2F; unstable"></a>Stable &#x2F; unstable</h4><p>In particular, many sorted data we met will be in form as record, which each record contains a key and satellite data. In practice, we wish to permute the satelliete data as well. </p>
<p>We define stable, as if before sorting a[i] &#x3D;&#x3D; a[j], then</p>
<ul>
<li>Stable means after sorting, a[i]’s new position is before a[j].</li>
<li>Vice versa</li>
</ul>
<h4 id="Adaptive"><a href="#Adaptive" class="headerlink" title="Adaptive"></a>Adaptive</h4><p>The bahaviour&#x2F;performace of algorithm affected by data values (distribution of sorted data). </p>
<h4 id="In-place"><a href="#In-place" class="headerlink" title="In place"></a>In place</h4><p>If the algorithm uses constant amount of memory. (And we wish this amount to be relatively small compare with input size)<br><strong>External sorting</strong> is class of algorithm that handle, large amount of data that store in external device, when data does not fit into main memory of computing device. Result the data must reside slower external memory. The in-place property will be very valueable. </p>
<h2 id="O-n-2-sort"><a href="#O-n-2-sort" class="headerlink" title="O(n^2) sort"></a>O(n^2) sort</h2><h4 id="Bubble-sort"><a href="#Bubble-sort" class="headerlink" title="Bubble sort"></a>Bubble sort</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int *bubbleSort(int *array, int size) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        int swapCount = 0;</span><br><span class="line">        // Always start from 0</span><br><span class="line">        // Swap the element not <span class="keyword">in</span> correct order <span class="keyword">in</span> path</span><br><span class="line">        <span class="keyword">for</span> (int j = 1; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[j - 1]) &#123;</span><br><span class="line">                swap(array, j , j - 1);</span><br><span class="line">                swapCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Adaptive</span><br><span class="line">        <span class="keyword">if</span> (swapCount == 0) <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int *selectionSort(int *array, int size) &#123;</span><br><span class="line">    // scan through array from index i, start with 0</span><br><span class="line">    // find min from index i+1, swap min to i</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        <span class="keyword">for</span> (int j = i + 1; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[min]) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int *bubbleSort(int *array, int size) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = 1; i &lt; size; i++) &#123;</span><br><span class="line">        // treat first i items as sorted</span><br><span class="line">        int val = array[i];</span><br><span class="line">        int j = i - 1;</span><br><span class="line">        // Insert A[j] into sorted sequence A[1..i-1]</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= 0 &amp;&amp; array[j] &gt; val) &#123;</span><br><span class="line">            array[j + 1] = array[j];            </span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + 1] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Shell-sort"><a href="#Shell-sort" class="headerlink" title="Shell sort"></a>Shell sort</h4><h4 id="Summary-of-Performance"><a href="#Summary-of-Performance" class="headerlink" title="Summary of Performance"></a>Summary of Performance</h4><h2 id="O-nlog-n-sort"><a href="#O-nlog-n-sort" class="headerlink" title="O(nlog(n)) sort"></a>O(nlog(n)) sort</h2><h2 id="Comparison-sort"><a href="#Comparison-sort" class="headerlink" title="Comparison sort"></a>Comparison sort</h2><p>From all above, these algorithm shares an intersting property, the sorted order they determined is basd only on comparison between input elements. We call above algorithm <strong>comparison sort</strong>.</p>
<h4 id="Decision-Treee"><a href="#Decision-Treee" class="headerlink" title="Decision Treee"></a>Decision Treee</h4><p>In comparison sort, we use only comparison between two element to gain info about ordering. We may construct a model to analysis the general performance of comparison sort. A decision tree is a full binary tree that represents the comparison between elements that are performed by a particular sorting algorithm. </p>
<p>Since each sorting algorithm may result n! different outcome, so the leave node in the full binary tree would be at least n!. The lower-bound then would be height of tree, which will be nlog(n).</p>
<p>Quicksort and heapsort are asmptopically optimal, as both’s worst case match with this lower bound.</p>
<h2 id="non-comparative-sorting-algorithm"><a href="#non-comparative-sorting-algorithm" class="headerlink" title="non-comparative sorting algorithm"></a>non-comparative sorting algorithm</h2><p>There is algorithm that do not base on comparison, thus not bounded by the lower bound of decision tree. </p>
<h4 id="Counting-sort"><a href="#Counting-sort" class="headerlink" title="Counting sort"></a>Counting sort</h4><p>Counting sort is a stable sort, and require extra memory use. It’s stable property is important for other reason, for radix sort may work using counting sort. </p>
<p>Algorithm describe</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// A is array, B is output sorted array, k is upperbound of <span class="built_in">integer</span> 0..k</span><br><span class="line">Counting-<span class="built_in">sort</span>(A, B, k) &#123;</span><br><span class="line">    Let C[0..k] be a new array, initial all as 0</span><br><span class="line"></span><br><span class="line">    // Using hashtable property to achieve O(1) <span class="keyword">for</span> each insert</span><br><span class="line">    <span class="keyword">for</span> j = 1 to A.length</span><br><span class="line">        C[A[j]] += 1</span><br><span class="line">    // Now C, contains info about element <span class="keyword">in</span> A and the num of duplicate</span><br><span class="line">    // By <span class="built_in">sum</span> up previous element, C[i] now contains info of ideal index of each element</span><br><span class="line">    <span class="keyword">for</span> i = i .. k</span><br><span class="line">        C[i] += C[i - 1]</span><br><span class="line">    </span><br><span class="line">    // By traversing from back, one can ensure stable property</span><br><span class="line">    <span class="keyword">for</span> j = A.length .. 1</span><br><span class="line">        B[C[A[j]]] = A[j]</span><br><span class="line">        C[A[j]] -= 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This algorithm have time complexity of O(n + k), consider k &lt;&#x3D; n for most used cases, which will be O(n). It seems out-performed to nlog(n) sort, however consider it usage cases, it only perfrom good with k is small. In most sorting scenoio, we use int, which have 2^32 possibility, but the size of input often do not meet this number. Hence it’s direct uses case is limited, tho it can perform well when combined with Radix sort. </p>
<h4 id="Radix-sort"><a href="#Radix-sort" class="headerlink" title="Radix sort"></a>Radix sort</h4><p>Radix’s sort algorithm is very simple, it applys stable Counting-sort the index from end to front, it requires stable sort property as if not stable, the sequence determined in higher index might not be in sorted order. Such as 13, 14, one can’t tell the sequence by only inspect index ‘1’, and thus must be stable and ensure lower-index’s sequence determined before higher index.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Radix-<span class="built_in">sort</span>(A, d)</span><br><span class="line">    <span class="keyword">for</span> i = 1 .. d</span><br><span class="line">        use a stable <span class="built_in">sort</span> to <span class="built_in">sort</span> array A on digit i</span><br></pre></td></tr></table></figure>

<p>The time complexity would be O(m*n), where n is number of index and m is the possibility in index. Radix sort perform better than comparison sort. </p>
<p>There is few disadvantage of Radix sort</p>
<ol>
<li>Although it tooks less pass for n element, but each pass may be longer (such as int, either takes 4 sort on the byte or 1 sort in 32 bits, not ideal as one comparison)</li>
<li>Quicksort ultilize hardware cashes more effectively than radix.</li>
<li>The stable sort algorithm always take extra memory, which many O(n*log(n)) uses in place memory. </li>
<li>Conclusion would be, which sorting algorithm we use depend on the chracteristic of data we sort, implementation of the machine and the memory.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/27/Sorting/" data-id="cl2goimqk0000hotr17k5axtv" data-title="Sorting" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sorting/" rel="tag">Sorting</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/COMP2521/">COMP2521</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ADT/" rel="tag">ADT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COMP2521/" rel="tag">COMP2521</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Language/" rel="tag">Language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Personal/" rel="tag">Personal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programming-Paradigm/" rel="tag">Programming Paradigm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Report/" rel="tag">Report</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sorting/" rel="tag">Sorting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Theory/" rel="tag">Theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ADT/" style="font-size: 12.5px;">ADT</a> <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/COMP2521/" style="font-size: 12.5px;">COMP2521</a> <a href="/tags/Data-Structure/" style="font-size: 20px;">Data Structure</a> <a href="/tags/Graph/" style="font-size: 15px;">Graph</a> <a href="/tags/Language/" style="font-size: 10px;">Language</a> <a href="/tags/Personal/" style="font-size: 10px;">Personal</a> <a href="/tags/Programming-Paradigm/" style="font-size: 10px;">Programming Paradigm</a> <a href="/tags/Report/" style="font-size: 10px;">Report</a> <a href="/tags/Sorting/" style="font-size: 10px;">Sorting</a> <a href="/tags/Theory/" style="font-size: 15px;">Theory</a> <a href="/tags/Tree/" style="font-size: 17.5px;">Tree</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/04/Things-I-know-so-far/">Things I know so far</a>
          </li>
        
          <li>
            <a href="/2022/05/03/Hash-Table/">Hash Table</a>
          </li>
        
          <li>
            <a href="/2022/05/03/Dynamic-Programming/">Dynamic Programming</a>
          </li>
        
          <li>
            <a href="/2022/04/28/Graph-Algorithm/">Graph Algorithm</a>
          </li>
        
          <li>
            <a href="/2022/04/28/DFS/">DFS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>